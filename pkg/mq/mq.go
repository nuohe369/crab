package mq

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/nuohe369/crab/pkg/mq/internal"
)

// Message represents message structure
type Message struct {
	ID      string // Message ID (generated by MQ)
	Topic   string // Topic
	Payload []byte // Message body
}

// Handler is the message handler function
type Handler func(ctx context.Context, msg *Message) error

// MQ is the message queue interface
type MQ interface {
	// Publish publishes message (immediately consumable)
	Publish(ctx context.Context, topic string, payload []byte) error

	// PublishDelay publishes delayed message
	// delay: delay duration, message can be consumed after delay
	PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error

	// Consume consumes messages (blocking)
	// group: consumer group name, messages in same group are processed by only one consumer
	Consume(ctx context.Context, topic, group string, handler Handler) error

	// Ack acknowledges message processed
	Ack(ctx context.Context, topic, group, msgID string) error

	// Close closes connection
	Close() error

	// GetRaw gets underlying client (for special scenarios)
	// Redis: returns redis.UniversalClient
	// RabbitMQ: returns *amqp.Channel
	GetRaw() any
}

// Config represents MQ configuration
type Config struct {
	Driver string `toml:"driver"` // redis or rabbitmq

	// Redis Streams configuration
	Redis RedisConfig `toml:"redis"`

	// RabbitMQ configuration (reserved)
	RabbitMQ RabbitMQConfig `toml:"rabbitmq"`
}

// RedisConfig represents Redis Streams configuration
type RedisConfig struct {
	// Standalone mode
	Addr     string `toml:"addr"`
	Password string `toml:"password"`
	DB       int    `toml:"db"`

	// Cluster mode
	Cluster string `toml:"cluster"`

	// Streams configuration
	MaxLen int64 `toml:"max_len"` // Stream max length, 0 means unlimited
}

// RabbitMQConfig represents RabbitMQ configuration (reserved)
type RabbitMQConfig struct {
	URL string `toml:"url"` // amqp://user:pass@host:port/vhost
}

var defaultMQ MQ

// Init initializes default MQ client
// If driver is empty, skip initialization
func Init(cfg Config) error {
	if cfg.Driver == "" {
		log.Println("mq: driver not configured, skip initialization")
		return nil
	}

	client, err := New(cfg)
	if err != nil {
		return err
	}
	defaultMQ = client
	return nil
}

// MustInit initializes and panics on error
// If driver is empty, skip initialization
func MustInit(cfg Config) {
	if err := Init(cfg); err != nil {
		log.Fatalf("mq initialization failed: %v", err)
	}
}

// Get returns default MQ client
func Get() MQ {
	return defaultMQ
}

// Close closes default client
func Close() {
	if defaultMQ != nil {
		defaultMQ.Close()
	}
}

// mqWrapper wraps internal implementation, converts Message type
type mqWrapper struct {
	impl interface {
		Publish(ctx context.Context, topic string, payload []byte) error
		PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error
		Consume(ctx context.Context, topic, group string, handler func(ctx context.Context, msg *internal.Message) error) error
		Ack(ctx context.Context, topic, group, msgID string) error
		Close() error
		GetRaw() any
	}
}

func (w *mqWrapper) Publish(ctx context.Context, topic string, payload []byte) error {
	return w.impl.Publish(ctx, topic, payload)
}

func (w *mqWrapper) PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error {
	return w.impl.PublishDelay(ctx, topic, payload, delay)
}

func (w *mqWrapper) Consume(ctx context.Context, topic, group string, handler Handler) error {
	return w.impl.Consume(ctx, topic, group, func(ctx context.Context, msg *internal.Message) error {
		return handler(ctx, &Message{
			ID:      msg.ID,
			Topic:   msg.Topic,
			Payload: msg.Payload,
		})
	})
}

func (w *mqWrapper) Ack(ctx context.Context, topic, group, msgID string) error {
	return w.impl.Ack(ctx, topic, group, msgID)
}

func (w *mqWrapper) Close() error {
	return w.impl.Close()
}

func (w *mqWrapper) GetRaw() any {
	return w.impl.GetRaw()
}

// New creates MQ client (auto select implementation based on config)
func New(cfg Config) (MQ, error) {
	switch cfg.Driver {
	case "redis", "":
		// Default uses Redis Streams
		impl, err := internal.NewRedisStreams(internal.RedisStreamsConfig{
			Addr:     cfg.Redis.Addr,
			Password: cfg.Redis.Password,
			DB:       cfg.Redis.DB,
			Cluster:  cfg.Redis.Cluster,
			MaxLen:   cfg.Redis.MaxLen,
		})
		if err != nil {
			return nil, err
		}
		return &mqWrapper{impl: impl}, nil
	case "rabbitmq":
		impl, err := internal.NewRabbitMQ(internal.RabbitMQConfig{
			URL: cfg.RabbitMQ.URL,
		})
		if err != nil {
			return nil, err
		}
		return &mqWrapper{impl: impl}, nil
	default:
		return nil, fmt.Errorf("mq: unsupported driver: %s", cfg.Driver)
	}
}

// ============ Convenience methods (using default client) ============

// Enabled checks if MQ is enabled
func Enabled() bool {
	return defaultMQ != nil
}

// Publish publishes message (using default client)
func Publish(ctx context.Context, topic string, payload []byte) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Publish(ctx, topic, payload)
}

// PublishDelay publishes delayed message (using default client)
func PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.PublishDelay(ctx, topic, payload, delay)
}

// Consume consumes messages (using default client)
func Consume(ctx context.Context, topic, group string, handler Handler) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Consume(ctx, topic, group, handler)
}

// Ack acknowledges message (using default client)
func Ack(ctx context.Context, topic, group, msgID string) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Ack(ctx, topic, group, msgID)
}

// GetRaw gets underlying client (using default client)
func GetRaw() any {
	if defaultMQ == nil {
		return nil
	}
	return defaultMQ.GetRaw()
}
