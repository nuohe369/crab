// Package mq provides message queue functionality with support for Redis Streams and RabbitMQ
// Package mq 提供消息队列功能，支持 Redis Streams 和 RabbitMQ
package mq

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/nuohe369/crab/pkg/mq/internal"
)

// Message represents message structure
// Message 表示消息结构
type Message struct {
	ID      string // Message ID (generated by MQ) | 消息 ID（由 MQ 生成）
	Topic   string // Topic | 主题
	Payload []byte // Message body | 消息体
}

// Handler is the message handler function
// Handler 是消息处理函数
type Handler func(ctx context.Context, msg *Message) error

// MQ is the message queue interface
// MQ 是消息队列接口
type MQ interface {
	// Publish publishes message (immediately consumable)
	// Publish 发布消息（立即可消费）
	Publish(ctx context.Context, topic string, payload []byte) error

	// PublishDelay publishes delayed message
	// delay: delay duration, message can be consumed after delay
	// PublishDelay 发布延迟消息
	// delay: 延迟时长，消息在延迟后可被消费
	PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error

	// Consume consumes messages (blocking)
	// group: consumer group name, messages in same group are processed by only one consumer
	// Consume 消费消息（阻塞）
	// group: 消费者组名称，同组内的消息只会被一个消费者处理
	Consume(ctx context.Context, topic, group string, handler Handler) error

	// Ack acknowledges message processed
	// Ack 确认消息已处理
	Ack(ctx context.Context, topic, group, msgID string) error

	// Close closes connection
	// Close 关闭连接
	Close() error

	// GetRaw gets underlying client (for special scenarios)
	// Redis: returns redis.UniversalClient
	// RabbitMQ: returns *amqp.Channel
	// GetRaw 获取底层客户端（用于特殊场景）
	// Redis: 返回 redis.UniversalClient
	// RabbitMQ: 返回 *amqp.Channel
	GetRaw() any
}

// Config represents MQ configuration
// Config 表示 MQ 配置
type Config struct {
	Driver   string         `toml:"driver"`   // redis or rabbitmq | redis 或 rabbitmq
	Redis    RedisConfig    `toml:"redis"`    // Redis Streams configuration | Redis Streams 配置
	RabbitMQ RabbitMQConfig `toml:"rabbitmq"` // RabbitMQ configuration (reserved) | RabbitMQ 配置（保留）
}

// RedisConfig represents Redis Streams configuration
// RedisConfig 表示 Redis Streams 配置
type RedisConfig struct {
	Addr     string `toml:"addr"`     // Standalone mode address | 单机模式地址
	Password string `toml:"password"` // Password | 密码
	DB       int    `toml:"db"`       // Database number | 数据库编号
	Cluster  string `toml:"cluster"`  // Cluster mode addresses | 集群模式地址
	MaxLen   int64  `toml:"max_len"`  // Stream max length, 0 means unlimited | 流最大长度，0 表示无限制
}

// RabbitMQConfig represents RabbitMQ configuration (reserved)
// RabbitMQConfig 表示 RabbitMQ 配置（保留）
type RabbitMQConfig struct {
	URL string `toml:"url"` // amqp://user:pass@host:port/vhost
}

var defaultMQ MQ // Default MQ client instance | 默认 MQ 客户端实例

// Init initializes default MQ client
// If driver is empty, skip initialization
// Init 初始化默认 MQ 客户端
// 如果 driver 为空，跳过初始化
func Init(cfg Config) error {
	if cfg.Driver == "" {
		log.Println("mq: driver not configured, skip initialization")
		return nil
	}

	client, err := New(cfg)
	if err != nil {
		return err
	}
	defaultMQ = client
	return nil
}

// MustInit initializes and panics on error
// If driver is empty, skip initialization
// MustInit 初始化，失败时 panic
// 如果 driver 为空，跳过初始化
func MustInit(cfg Config) {
	if err := Init(cfg); err != nil {
		log.Fatalf("mq initialization failed: %v", err)
	}
}

// Get returns default MQ client
// Get 返回默认 MQ 客户端
func Get() MQ {
	return defaultMQ
}

// Close closes default client
// Close 关闭默认客户端
func Close() {
	if defaultMQ != nil {
		defaultMQ.Close()
	}
}

// mqWrapper wraps internal implementation, converts Message type
type mqWrapper struct {
	impl interface {
		Publish(ctx context.Context, topic string, payload []byte) error
		PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error
		Consume(ctx context.Context, topic, group string, handler func(ctx context.Context, msg *internal.Message) error) error
		Ack(ctx context.Context, topic, group, msgID string) error
		Close() error
		GetRaw() any
	}
}

func (w *mqWrapper) Publish(ctx context.Context, topic string, payload []byte) error {
	return w.impl.Publish(ctx, topic, payload)
}

func (w *mqWrapper) PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error {
	return w.impl.PublishDelay(ctx, topic, payload, delay)
}

func (w *mqWrapper) Consume(ctx context.Context, topic, group string, handler Handler) error {
	return w.impl.Consume(ctx, topic, group, func(ctx context.Context, msg *internal.Message) error {
		return handler(ctx, &Message{
			ID:      msg.ID,
			Topic:   msg.Topic,
			Payload: msg.Payload,
		})
	})
}

func (w *mqWrapper) Ack(ctx context.Context, topic, group, msgID string) error {
	return w.impl.Ack(ctx, topic, group, msgID)
}

func (w *mqWrapper) Close() error {
	return w.impl.Close()
}

func (w *mqWrapper) GetRaw() any {
	return w.impl.GetRaw()
}

// New creates MQ client (auto select implementation based on config)
// New 创建 MQ 客户端（根据配置自动选择实现）
func New(cfg Config) (MQ, error) {
	switch cfg.Driver {
	case "redis", "":
		// Default uses Redis Streams | 默认使用 Redis Streams
		impl, err := internal.NewRedisStreams(internal.RedisStreamsConfig{
			Addr:     cfg.Redis.Addr,
			Password: cfg.Redis.Password,
			DB:       cfg.Redis.DB,
			Cluster:  cfg.Redis.Cluster,
			MaxLen:   cfg.Redis.MaxLen,
		})
		if err != nil {
			return nil, err
		}
		return &mqWrapper{impl: impl}, nil
	case "rabbitmq":
		impl, err := internal.NewRabbitMQ(internal.RabbitMQConfig{
			URL: cfg.RabbitMQ.URL,
		})
		if err != nil {
			return nil, err
		}
		return &mqWrapper{impl: impl}, nil
	default:
		return nil, fmt.Errorf("mq: unsupported driver: %s", cfg.Driver)
	}
}

// ============ Convenience methods (using default client) | 便捷方法（使用默认客户端）============

// Enabled checks if MQ is enabled
// Enabled 检查 MQ 是否已启用
func Enabled() bool {
	return defaultMQ != nil
}

// Publish publishes message (using default client)
// Publish 发布消息（使用默认客户端）
func Publish(ctx context.Context, topic string, payload []byte) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Publish(ctx, topic, payload)
}

// PublishDelay publishes delayed message (using default client)
// PublishDelay 发布延迟消息（使用默认客户端）
func PublishDelay(ctx context.Context, topic string, payload []byte, delay time.Duration) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.PublishDelay(ctx, topic, payload, delay)
}

// Consume consumes messages (using default client)
// Consume 消费消息（使用默认客户端）
func Consume(ctx context.Context, topic, group string, handler Handler) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Consume(ctx, topic, group, handler)
}

// Ack acknowledges message (using default client)
// Ack 确认消息（使用默认客户端）
func Ack(ctx context.Context, topic, group, msgID string) error {
	if defaultMQ == nil {
		return fmt.Errorf("mq: not initialized")
	}
	return defaultMQ.Ack(ctx, topic, group, msgID)
}

// GetRaw gets underlying client (using default client)
// GetRaw 获取底层客户端（使用默认客户端）
func GetRaw() any {
	if defaultMQ == nil {
		return nil
	}
	return defaultMQ.GetRaw()
}
